# 1. CASE STUDIES AND TALES OF WOE
----------------------------------
* Punishing competence with responsibility
------------------------------------------
Congratulations, you've earned a promotion or a new job. You've impressed those around you with your experience and ability to master your engineering skills. 

As you're going through your new responsibilities, something stands out, an old critical system that nobody knows very well, if at all. Good news, the thing nobody else wanted to deal 
with is now your problem. 

Somebody has to own it and it might as well be you. 

The intent may be a test of your skills. You've done well so far, but you're not quite at the next level. This one last task will show whether you've got the temperament, spirit, and 
skills for that next promotion. 

An opportunity to show off what you've learned and gain some additional experience along the way. 

Alternatively, this dubious gift could be seen as a compliment. You're so good that you can handle any challenge and nobody else is capable of conquering the beast. 

This is an opportunity to shine or be knocked down a peg or two. Does it truly matter how you got to this point? Not really, to be honest. What matters more is your strategy from this 
point forward. 

You have unique opportunity to maintain and establish a new chapter in the book of this project. There could be many more or this could be the end of this poor, decrepit program. 

What exactly is legacy software? In computing, legacy software is software superseded by another system but is still in widespread use and therefore difficult to replace. 

Here are some practical examples of legacy software applications. 

A content management system built with the previous generation of both the language and framework, yet is used daily by hundreds who relied on it for their livelihood. 

An affiliate system with tens of thousands of users that could not ingest data quickly enough to calculate. Each passing day introduced a greater data backlog and more frustrated 
affiliates demanding accurate data and payouts. 

A monolithic website publishing system that included both an editor and the front end that hadn't been deployed to production in years, but couldn't be turned off out of fear from the 
last outage that was caused when it was attempted. 

An open source project with thousands of users, an issue queue with scores of issues, bug reports and patches that was abandoned by its primary author and maintainer. 

Each of these systems was important at one point and still is. However, they are no longer the latest and greatest. 

Teams or individual engineers consider them burdensome to maintain. 

Each was important to its audience. The opportunity and responsibility of owning and managing a legacy system is a pivotal moment. Your approach from the very beginning will set the tone 
for the duration of your experience.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Respecting history
--------------------
Software is written and developed by people, typically with best intentions. 

They may be professional, they may be amateur, and they may be writing a program for the very first time. 

Regardless of their journey, they have created something tangible that can be used. People have feelings, hopes, and dreams and pride in their accomplishments. 

Engineering can be both difficult and rewarding. The end result may be a utility to solve a specific problem. It may be a shared solution within a department. It could even be a 
commercial product with paying customers. 

Regardless of what type of system it is, it was built with a purpose. The requirements and intents that led to the creation of the service may be lost with time. 

They may be perfectly well documented. There's a very good chance that a system is being used in a different way than what was originally intended. 

If a system seems unmanageable now, take a deep breath. 

Try to empathize with those who came before you. When writing software, nobody creates a dumpster fire on purpose. 

You could say that the road to sorrow is paved with good intentions, and acting in good faith doesn't guarantee success. 

Something that I've learned in an excruciating and visceral way is that you should assume the best intentions of the people and the team that built a piece of software. 

Badmouthing a piece of software can be synonymous with insulting the people who wrote it. There's an excellent chance that someone involved with that project is still around to hear your 
criticism of it. 

Would you walk up to someone and tell them that they're terrible engineers? No? Then why would you say that their work was awful? The result of their blood, sweat, and tears has no value. 

If a system works, even if it's subjectively ugly and weird it still works and should be respected. If it didn't work, it'd be turned off or retired, or one would assume. 

More on that later. The best practices of two, five, or 10 years ago may be different from those of today. The dependencies of the system may be outdated. 

It may rely on an outdated version of a database with dozens of critical security vulnerabilities, yet it still performs its duty. 

It may be challenging to maintain or to add on, or more accurately, those who are responsible for it don't know how to maintain it. 

Somebody built it and got it to the point where it is today. It's less important to be proper or academically correct. 

Subjectively and objectively, you may be accurate but the system may be imperfect. Does it matter? Not really. Could it be done better? Sure. 

Is that a point worth making? Absolutely not. Assume the best intentions, respect what came before, and look forward to the next chapter in the application's legacy. 

As you assume ownership of a legacy system, documentation will play a key role in your understanding. So what type of manual should you be looking for and writing?

------------------------------------------------------------------------------------------------------------------------------------------------------------------

* Effective documentation
-------------------------
Effective documentation. Writing documentation is a task that's easy to procrastinate. It's fun to build and plan things, but there's little glory in writing documentation. 

A good manual is an essential component of a healthy system. What does effective documentation look like? A good manual should be both thorough and concise, which sounds contradictory. 

There's a case for both. The thoroughness should answer essential questions about the system. 

What does the application do? 

Who maintains the software and is responsible for it? 

Why was it created? 

How does it work? 

How do you know it's working correctly? 

What are the troubleshooting steps if it isn't working properly? 

Make sure that there's enough information to answer the most important questions. This is a delicate balance. 

When is there too much information? 

The conciseness should be the brevity of information. Get to the point and get out of the way. 

Consider a cooking blog that stretches a recipe into pages of descriptions of how dill makes you feel and helpful affiliate links to every kitchen gadget known to humanity. 

If you just want to make dinner and see a recipe without having to scroll, all that commentary and distractions are exactly just that. 

An effective manual makes its point and gets out of the way. 

It doesn't have to be lengthy, just informative. So how do you find a balance between too much and too little documentation? 

Logical organization and priority hierarchy will improve navigation. 

Brief statements with logical paragraph breaks, concise lists, and clean formatting really make understanding the system easier for others. 

The goal should be to educate. 

If there was an emergency and you weren't available, 

would someone else know what to do if they read the manual? 

Would they know how to find it? 

Is it spread out in multiple locations and should be consolidated to save effort? 

If a piece of software is part of a larger system, it's definitely recommended to link to the larger systems documentation and avoid duplication. 

For example, deployment instructions may be the same for a collection of applications. So just refer to the main instructions and only document exceptions or specific configurations. 

Throughout your journey to own a system, you should be recording your findings in a manual, knowledge base, wiki, readme, or some other centralized and accessible location. 

Save the next person the time. There's no advantage to siloing information. And memory is fallible. The longer you wait to write it down, the more likely that details will be missed. 

Have you heard the lazy excuse that a program is so perfectly designed that it's self-documenting? If you've made that excuse, I hope you feel a twinge of shame. 

Code should be commented and logical, but where's the description of the overall intent, how to manage the system? Something is obviously better than nothing, but a well-documented 
interior and an obtuse confusing exterior are a detriment to anyone trying to maintain the system. 

Build the knowledge base to save the next person time and prevent information siloing. As you learn more about a system, organize and document it. 

An important question that should be documented is, who is the actual owner of the system?


------------------------------------------------------------------------------------------------------------------------------------------------------------------

























































